<!DOCTYPE html>
<html lang="en">

<!-- TODO: possibly move any web resources (e.g. Shoelace) to local copy in case we don't have internet access there. -->
<script>
    document.addEventListener("DOMContentLoaded", function () {
        // Setup key controls help dialog.
        const openButton = document.querySelector('#btnControls');
        const closeButton = document.querySelector('#btnControlsClose');
        const dialog = document.querySelector('.help_keycombos');
        openButton.addEventListener('click', () => dialog.show());
        closeButton.addEventListener('click', () => dialog.hide());

        // Setup for references dialog
        document.querySelector('#btnRefs').addEventListener('click', () => document.querySelector('.help_refs').show());
        document.querySelector('#btnrefsClose').addEventListener('click', () => document.querySelector('.help_refs').hide());

        // Replace .ipsum-class elements with dummy content onload until we generate real poster text.
        var ipsumTags = document.querySelectorAll(".ipsum");
        for (var i = 0; i < ipsumTags.length; i++) {
            ipsumTags[i].innerHTML = `
                Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore 
                et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut 
                aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum 
                dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui 
                officia deserunt mollit anim id est laborum.`
        }

        // Syntax highlighting
        hljs.highlightAll();

        // Start timer to select the next tab in the group, if auto-cycle is enabled.
        window.setInterval(() => {
            if (!document.querySelector('#autocycle').checked) {
                return;
            }
            const tabGroup = document.querySelector('sl-tab-group');
            if (tabGroup) {
                tabDelta(1);
                // console.log("Switching to tab", nextIndex);
            }
       }, 60*1000);  // 1 minute
       // }, 500);  // 0.5s, to debug.
    });

    function tabDelta(dTab) {
        const tabGroup = document.querySelector('sl-tab-group');
        if (tabGroup) {
            const tabs = tabGroup.querySelectorAll('sl-tab');
            const activeTab = tabGroup.querySelector('sl-tab[active]');
            const activeIndex = Array.from(tabs).indexOf(activeTab);
            let nextIndex = (activeIndex + dTab);
            // Hack to fix mod in both directions.
            if (dTab > 0)
                nextIndex = nextIndex % tabs.length;
            else if (dTab < 0 && nextIndex < 0)
                nextIndex = tabs.length - 1;
            tabs[nextIndex].click();
            // console.log("Switching to tab", nextIndex);
        }
    }

    document.addEventListener("keydown", function (event) {
        if (event.key === "?") {
            // Show the help dialog
            document.querySelector('.help_keycombos').show();
        }
        // If hitting a, toggle autocycle
        else if (event.key === "a") {
            document.querySelector('#autocycle').checked = !document.querySelector('#autocycle').checked;
        }
        // j/k move tabs.
        else if (event.key === "j") {
            tabDelta(1);
        }
        else if (event.key === "k") {
            tabDelta(-1);
        }
    });
</script>

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GPGPU Audio Benchmark Framework</title>

    <!-- Import Shoelace via CDN for buttons and styling -->
    <link rel="stylesheet" media="(prefers-color-scheme:light)"
        href="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.16.0/cdn/themes/light.css" />
    <link rel="stylesheet" media="(prefers-color-scheme:dark)"
        href="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.16.0/cdn/themes/dark.css"
        onload="document.documentElement.classList.add('sl-theme-dark');" />
    <script type="module"
        src="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.16.0/cdn/shoelace-autoloader.js"></script>

    <!-- Import highlight.js for code highlighting -->
    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/tokyo-night-dark.min.css">
    <!--<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/dark.min.css">-->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/go.min.js"></script> -->

    <!-- Onto our CSS -->
    <style>
        html,
        body {
            height: 100%;
        }

        body {
            font-family: Helvetica, Arial, sans-serif;
            font-size: 1.1em;
            line-height: 1.25;
            background-color: #111;
            color: #d0d0d0;
            /* fully-justify */
            text-align: justify;
            text-justify: inter-word;
        }

        /* Background image provided by DAFx conference. */
        body::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('DAFx24Background-16-9.png');
            background-size: cover;
            background-repeat: no-repeat;
            background-position: center;
            opacity: 0.25;
            z-index: -1;
        }

        .floating-logo {
            position: absolute;
            right: 250px;
            margin-left: 0;
            margin-top: 0;
            float: right;
            width: 240px;
            height: auto;
            z-index: 100;
        }
        .floating-logo2 {
            position: absolute;
            right: 125px;
            margin-left: 0;
            margin-top: 0;
            float: right;
            width: 112px;
            height: auto;
            z-index: 100;
        }


        .top-bar {
            /* text-align: center; */
            text-align: left;
        }

        #container {
            display: flex;
            flex-direction: column;

            /* To match screen at DAFx */
            aspect-ratio-off: 16 / 9;
            width: 100%;
            height: 100%;

        }

        .fig {
            display: block;
            margin-left: auto;
            margin-right: auto;
            width: 75%;
        }

        .content {
            display: flex;
            flex: 1;
            justify-content: space-between;
            padding-left: 25px; /* overscan @ dafx */
        }

        div.prose {
            margin-top: 10px;
            margin-bottom: 10px;
        }

        .column {
            /* flex-basis: 33%; */
            flex: 0 0 33%;
            width:33%;
        }

        .column {
            padding-right: 25px;
        }

        .column+.column {
            padding-left: 25px;
        }

        .bottom-bar {
            margin: 0;
            padding: 0;
            text-align: center;
        }

        #qr-code-container {
            position: absolute;
            top: 0;
            right: 0;
            z-index: 100;
            display: inline-block;
            padding: 6px;
            background-color: #ccc;
        }
    </style>
</head>

<body>
    <div id="container">
        <div class="top-bar">
            <h1>General-Purpose GPU Audio Benchmark Framework</h1>
            <h4><i>Travis Skare, travissk@stanford.edu</i></h4>
        </div>

        <img src="DAFx24LogoBannerFlatTransparent.png" alt="DAFx-27 2024 Logo" class="floating-logo">
        <img src="slogo.png" alt="Stanford Logo" class="floating-logo2">

        <div class="content">
            <div class="column">
                <h2>Abstract</h2>
                <div class="prose">Acceleration of audio workloads on generally-programmable GPU (GPGPU) hardware offers
                    potentially high speedup factors, but also presents challenges in terms of development and
                    deployment. We can increasingly depend on such hardware being available in users' systems, yet few
                    real-time audio products use this resource.</div>
                <div class="prose">We propose a suite of benchmarks to qualify a GPU as suitable for batch or real-time
                    audio processing. This includes both microbenchmarks and higher-level audio domain benchmarks. We
                    choose metrics based on application, paying particularly close attention to latency tail
                    distribution. We propose an extension to the benchmark framework to more accurately simulate the
                    real-world request pattern and performance requirements when running in a digital audio workstation.
                    We run these benchmarks on two common consumer-level platforms: a PC desktop with a recent mid-range
                    discrete GPU and a Macintosh desktop with unified CPU-GPU memory architecture.</div>
                <h3>Goal: Create an extensible framework to answer questions such as:</h3>
                <div class="prose">
                    Can this system process audio on the GPU at real-time rates?
	                What is the overhead? What are the bounds on buffer size and sample rate?
	                How many tracks can be processed in real-time? What are the data transfer limits?
	                Does this platform excel at or struggle with certain subtasks?
                </div>
                <div class="prose">
                    Perhaps one platform has arithmetic throughput but slow memory access once working set exceeds some limit.
                </div>
                <h3>Test Systems</h3>
                <div>
                    <div class="prose">Benchmarks were written on NVIDA/CUDA and Apple/Metal platforms. The MacOS consumer and professional platorms both utilize a shared memory architecture we are interested in exploring for random memory accesses.</div>
                    <img class="fig" style="width:350px" src="figs/fig3.png" alt="Platforms" />
                    <img class="fig" style="width:350px" src="figs/tab2.png" alt="Platforms Table" />
                    <h5>Metrics</h5>
                    <div class="prose">
                        We measure two core metrics: latency and throughput. <b>Latency</b> is the wall-clock time in milliseconds between when an audio buffer is requested to be processed and when its results are available. This is our most important metric: if we miss the deadline for processing a single buffer, a recording take or a song may be ruined. We will report median, 95th percentile, and maximum audio buffer processing times, and care about tail latencies a great deal. In cases of excessive latency metrics, developers may add buffering and leverage the DAW's latency compensation. Batch processing tasks are less sensitive to latency, of course. We may say an audio processing task "meets the latency bar" if it is able to complete within the time allowed for its audio callback. This is defined as the audio buffer size divided by the sampling rate, minus some time for overhead.
                    </div>
                    <div class="prose">
                        Throughput measures how much data a system be processed over time, for example one may compute 500 Megabytes of data per second for some task A and 1,200 Megabytes per second for some task B. This is useful in considering how many tracks of 32-bit audio at a target sampling rate we can process, and when properly measured yields the overall speedup factor over a CPU process.
                    </div>
                </div>
            </div>


            <div class="column">
                <h2>Implementation and Results</h2>
                <sl-tab-group>
                    <sl-tab slot="nav" panel="result_format">Result Format</sl-tab>
                    <sl-tab slot="nav" panel="bench_kernellaunch">Kernel Launch</sl-tab>
                    <sl-tab slot="nav" panel="bench_rndmem">RndMem</sl-tab>
                    <sl-tab slot="nav" panel="bench_io">I/O</sl-tab>
                    <sl-tab slot="nav" panel="bench_modal">Modal Filters</sl-tab>
                    <!-- <sl-tab slot="nav" panel="bench_conv1d">Conv1D</sl-tab> -->
                    <sl-tab-panel name="bench_io">
                        <h4>I/O Benchmarks, Varying Data Mixes</h4>
                        <div class="prose">Anecdotally, I/O transfer time is a very common concern when discussing performing tasks at audio rates.</div>
                        <div class="prose">We measure the time to read and write data to and from the GPU. We vary the mix of reads and writes to see how the platform handles different mixes of I/O operations.</div>
                        <pre><code class="language-cpp">
// Kernel code is a no-op or performs a single trivial operation (Metal).
// We are measuring overhead involved in invoking a GPU function repeatedly.
                        </code></pre>   
                        <img class="fig" style="width:100%" src="figs/tab5.png" alt="I/O" />
                    </sl-tab-panel>
                    <sl-tab-panel name="bench_rndmem">
                        <h4>RndMem "graintable" memory access</h4>
                        <sl-card class="card-header">
                            <!-- <div slot="header">
                                Code
                                <sl-icon-button name="gear" label="Settings"></sl-icon-button>
                            </div> -->
                            <pre>
<code class="language-cpp">
// Simulated quasi-granular synthesis kernel.
// N virtual playheads read from areas of memory.
// This is intended to exerise some of the "unfortunate" cases:
//   - random memory access
//   - unalgned memory access between threads within a warp
//   - non-coalesced memory access between threads in a warp
// For simplicity we do not wrap around the end of the buffer inside 
//   the kernels here. We may wish to change this as it would disrupt
//   caching behavior a bit further; there
//   would be a point where a new cache line would be loaded.
__global__ void RndMemKernel(const float* sampleMem,
        const int* playheads, float* outBuf) {
    int trackidx = blockDim.x * blockIdx.x + threadIdx.x;
    int playhead = playheads[trackidx];
    for (int i = 0; i < BUFSIZE; i++) {
        // This benchmark is stressing random reads and writes from
        // global memory. Note the calling (host/CPU) code should
        // place these in varying locations across sample memory,
        // and likely unaligned, different loop lengths, etc.
        
        // Write is aligned and free of bank conflicts.
        outBuf[NTRACKS*i + trackidx] = sampleMem[playhead] + i;
    }
}

</code></pre>
                        </sl-card>
                        <img class="fig" style="display:inline-block;width:48%" src="figs/fig5.png" alt="Graintable" />
                        <img class="fig" style="display:inline-block;width:48%; vertical-align:top;" src="figs/tab6.png" alt="Graintable" />
                        <div class="prose">
                            This benchmark exhibits a number of undesirable memory access patterns.
                        </div>
                        <div class="prose">
                            The MacOS/Metal platform excels here, in terms of performance per watt.
                        </div>
                    </sl-tab-panel>
                    <sl-tab-panel name="result_format">
                        <h4>Configuration 
<pre>
<code>Usage: ./GPUAudioBench --buffersize 512 --benchmark datacopy2080
        --fs 48000 --ntracks 128 
Supported benchmarks:  [...omitted...]
Optional flags:
    --dawsim: Simulate DAW-like behavior
    --dawsim_delay: Simulated buffer interarrival time in milliseconds
    --skip-human-readable-summary: Disable human-readable summary
    --nruns: Number of runs
    --help: Print this help message
    --outputfile: Output file for stats
</code></pre>    
                        <h4>Output</h4>
                        Sample output from a run of a Conv1D benchmark which did <i>not</i> pass follows. A warning will be given if (median || p95 || maximum) latency caused an underrun.
                        <pre><code class="language-cpp">                 
Buffer Size: 512
Benchmark: Conv1D
FS: 48000
Number of Tracks: 256
Outer Runtime: 1118.35 ms
Max latency of 100 runs: 29.833042 ms
Success writing output stats to /tmp/gpubench_Conv1D_512_256.txt
p50: 10.897
p95: 11.551
max: 29.83304
WARNING: median latency 10.897 ms over 10.667 ms callback time limit.
</code></pre>
Whereas a successful run will report:
<pre>
<code>TODO
</code></pre>
                    </sl-tab-panel>
                    <sl-tab-panel name="bench_kernellaunch">
                        <h4>Kernel Launch Times</h4>
                        <pre><code class="language-cpp">
// Kernel code is a no-op or performs a single trivial operation (Metal).
// We are measuring kernel execution time.
                        </code></pre>   
                        <img class="fig" src="figs/fig4.png" alt="Kernel Launch Times" />
                    </sl-tab-panel>
                    <sl-tab-panel name="bench_modal">
                        <h4>Modal Synthesis via Phasor Filters</h4>
                        <div class="prose">We synthesize N modes of a modal resonator, each with a different frequency and decay time. The modes are excited by a single impulse at the beginning of the simulation and are modulated to require recomputation of some coefficients each loop.</div>
                        <div class="prose">Phasor filters are used, which are complex multiply-based. We use a custom cexpf function and custom complex multiplication on Metal, but may utilize cuComplex on CUDA platforms.</div>
                        <pre><code class="language-cpp">
// Placeholder for cexpf code
                        </code></pre>   
                        <h4>Optimization: Pre-mixing</h4>
                        <div class="prose">For high N, this is a very large amount of data and can saturate the PCIe bus for discrete GPU platforms. In v2 of the CUDA version of this benchmark, alongside earlier work, we tree-sum down inside each warp for a 32x reduction in output size (pre-mixed sets of modes). Please note the public repo needs to be updated with this modification.</div>
                        <pre><code class="language-cpp">
// Pairwise sum reduction: 32 -> 16 -> ... -> 1
for (int offset = 16; offset > 0; offset /= 2)
    merge_output += __shfl_down_sync(0xffffffff, merge_output, offset);
if (is_first_thread_in_warp) {
    output[which_warp*BUFFERSIZE + samp] = merge_output;
                        </code></pre>   
                        <h4>Performance</h4>
                        <img class="fig" src="figs/tab4.png" alt="Modal Synthesis" />
                        This benchmark exercises the FPUs (32-bit). We note the CUDA card scales further, as might be expected with significantly higher TDP.
                    </sl-tab-panel>
                    <sl-tab-panel name="bench_conv1d">This is the bench_conv1d tab panel.</sl-tab-panel>
                </sl-tab-group>
            </div>
            <!-- Third column, DAW-Sim and conclusions -->
            <div class="column">
                <h2>DAW Simulation Mode</h2>
                
                <div class="prose">The DAW-Sim mode is designed to improve on the batch-like microbenchmarks, simulating the request pattern seen by real-time audio processors.</div>
                <img class="fig" src="figs/fig2.png" alt="DAW-Sim" />

                <sl-details style="margin-top:20px" summary="Discussion: Spin vs Sleep">
                    <div class="prose">We may choose whether to sleep or actively spin; both have analogs in the DAW world. Impact of this choice varies under different conditions:</div>
                    <img class="fig" src="figs/tab7.png" alt="DAW-sim performance" />
                </sl-details>

                <div class="prose">We may see overall impact of DAW-Sim implementation across data transfer and synthesis tasks:</div>
                <img class="fig" src="figs/tab8.png" alt="DAW-sim performance" />

                <h2><sl-icon name="exclamation-triangle"></sl-icon> Caveats</h2>
                <ul>
                    <li>The code is not "DAW-Ready" and may abstract threading issues on each platform (potentially significant)</li>
                    <li>Thus, these tests are necessary but not sufficient for real-world usage.</li>
                    <li>Code has been, and is being, transformed to be more readable. You may wish to check out the <pre style="display:inline">v1.0</pre> tag.</li>
                </ul>
                <h2>Observations</h2>
                <ul>
                    <li>CUDA (discrete) and Metal (shared-memory) platforms excel in different tasks.</li>
                    <li>Arithmetic throughput is attractive but latency variation is concerning for real-world applications.</li>
                    <li>DAW simulation extension has a measurable effect and suggests impact of OS scheduler.</li>
                    <li>Future investigation: run these in an environment with measured contention (other GPGPU tasks running)</li>
                    <li>Future work: call this code across processes, or run it in-proc, from real VST/AU plugins.</li>
                </ul>
            </div>

        </div>



        <sl-dialog class="help_keycombos">
            <h3>Keyboard Controls</h3>
            <ul>
                <li><kbd>?</kbd> - Show this dialog</li>
                <li><kbd>a</kbd> - [A]utocycle toggle</li>
                <li><kbd>j/k</kbd> - Prev/Next in impl/results section.</li>
            </ul>
            <sl-button id="btnControlsClose" slot="footer" variant="primary">Close</sl-button>
        </sl-dialog>

        <sl-dialog style="--width: 800px;" class="help_refs">
            <h3>References - Poster</h3>
            <ul>
                <li>Background image and DAFx logo provided by DAFx 27 conference organizers</li>
                <li><a href="https://shoelace.style/" target="_blank">Shoelace</a> used for styling and buttons/cards
                    components</li>
                <li><a href="https://highlightjs.org/" target="_blank">highlight.js</a> used for syntax highlighting
                </li>
            </ul>
            <sl-button id="btnrefsClose" slot="footer" variant="primary">Close</sl-button>
            <h3>References - Poster</h3>
            <sl-details summary="(click to expand a scollable area)">
                <img src="figs/refs_image.png"/>
            </sl-details>
        </sl-dialog>

        <div class="bottom-bar">
            <div>
                <sl-switch id="autocycle">Auto-Cycle</sl-switch>
                <sl-button id="btnControls">Controls</sl-button>
                <sl-button id="btnPaper" href="https://github.com/IoSR-Surrey/DAFx24-Proceedings/raw/main/papers/DAFx24_paper_56.pdf" target="_blank">Paper (PDF)</sl-button>
                <sl-button id="btnRefs">References</sl-button>
            <div id="qr-code-container">
                <sl-qr-code value="https://github.com/tskare/gpuaudiobench" label="GitHub repo" size="100"
                    background="#CCC"></sl-qr-code>
            </div>

            </div>
        </div>
    </div> <!-- #container -->
</body>

</html>